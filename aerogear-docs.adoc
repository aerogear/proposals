= Aerogear.org Website Renewal

== Summary
Everyone should be able to contribute to aerogear.org docs with ease and effectiveness, regardless of the scope of their proposed change.
At the moment, changes are difficult to author and manage, and we hope to extend the site to include mobile.next and feedhenry material.
This proposal includes using asciibinder and a modular approach to documentation to help us deliver high quality documentation to enable the community use AeroGear software.

== Current Situation

* Multiple navigation paths - there are many ways to navigate to a document, and not all give a positive experience, eg https://aerogear.org/docs/
* Authoring requires rvm for preview, reducing contributions
* Confusing terminology - modules, 'getting started', platforms
* Asciidoc is used, but not a standard way
* Stale content
* Not much versioning - "As a developer I want to view the docs for a component I downloaded last year"

== Asciibinder

link:http://asciibinder.org/[Asciibinder] is used by some OSS projects for example:

* https://docs.openshift.org/latest/welcome/index.html
* https://docs.fedoraproject.org/
* http://manageiq.org/docs/

It uses asciidoc formatting, which is required for RH official documentation. Note, there is a PR to include markdown support.

"AsciiBinder is for documenting versioned, interrelated projects, producing different distributions of the docs as required."

== Modular documentation

NOTE: This should not be confused with link:https://redhat-documentation.github.io/modular-docs/[RH Modular Docs initiative].

Aerogear will consist of many components that have version specific documentation. Aerogear.org is where all that documentation will be published, however we want to make the process of contributing and publishing as easy as possible by:

. Documentation for a versioned feature is authored in it's own repo. Note that this could be a code repo, or a wiki repo.
. Documentation for all features is gathered as late as possible for publication on aerogear.org.

== Demo

This demo uses github and circleci, fork and build as required. 

Consider the following 'feature' doc repos:

* https://github.com/finp/sync-docs
* https://github.com/finp/push-docs
* https://github.com/finp/digger-docs

Each release branch is rendered using asciibinder, for example, see link:https://5-114535426-gh.circle-artifacts.com/0/home/circleci/docs/_preview/digger/latest/installation/digger-install-intro.html[Digger docs]. 

image::digger.png[digger docs]

To pull the features together, I've included a `package.json` file in each repo, and then made the master branch of those repos a dependency to render a more complete link:https://2-106556484-gh.circle-artifacts.com/0/home/circleci/docs/_preview/aerogear/latest/admin/about-admin-guide.html#[doc set], including sync and push docs.

image::aerogear.png[]

[NOTE] 
====
This requires some symlinks and concating topic files, see https://github.com/finp/shiftgear.

Note the mechanism for automatic assembly is just `npm install`:
----
"dependencies": {
   "digger-docs": "git@github.com:finp/digger-docs.git#master",
   "push-docs": "git@github.com:finp/push-docs.git#master",
   "sync-docs": "git@github.com:finp/sync-docs.git#master"
   }
----
====

== Search

A trivial approach to making AeroGear docs discoverable would be to link:https://support.google.com/customsearch/answer/2630963[create a custom search engine] targeting a url pattern such as aerogear.org/docs

This could then be extended to provide powerful search if we decide to publish particular doc sets. For example, npm could be used to publish all the branches for a component to a directory using `_distro.yml`, combined with a `package.json` such as:

----
"dependencies": {
   "sync-docs-latest": "git@github.com:finp/sync-docs.git#master"
   },
   "sync-docs-1.0.0": "git@github.com:finp/sync-docs.git#1.0.0"
   },
   "sync-docs-1.2.0": "git@github.com:finp/sync-docs.git#1.1.0"
   }
----   

This would publish a doc set combined with a custom engine that would allow users to search all versions of sync docs. 

== Conclusion

The advantages I see for this approach is:

* Mix and match component documentation
* Mix and match versions of component documenation
* Contributors write docs in the context of the feature, not on a monolithic website repo
* Tech writers can work with the development process 

NOTE: Typically, tech writers rail against feature documentation, wanting instead to document user stories. When the word 'feature' is mentioned above, it is in the context of a major user story, eg sync and push. 

Alternatives approaches include

* link:http://idratherbewriting.com/documentation-theme-jekyll/[Keep using Jekyll] but with a more docs-centric approach
* link:https://appdev.openshift.io/docs/nodejs-runtime.html[Simple asciidoc] user story approach


